use crate::client::intrinsic::vulnerability::ingest::IngestVulnerability;

//use crate::client::package::query::QueryPackage;
use crate::client::intrinsic::vulnerability::query::QueryVulnerability;
use graphql_client::reqwest::post_graphql;
use serde::{Deserialize, Serialize};

use crate::client::intrinsic::vuln_equal::VulnEqual;
use crate::client::intrinsic::IntrinsicGuacClient;
use crate::client::{Error, Id};

mod ingest;
mod query;
impl IntrinsicGuacClient {
    pub async fn ingest_vulnerability(&self, vuln: &VulnerabilityInputSpec) -> Result<Id, Error> {
        use self::ingest::ingest_vulnerability;
        let variables = ingest_vulnerability::Variables { vuln: vuln.into() };
        let response_body = post_graphql::<IngestVulnerability, _>(self.client(), self.url(), variables).await?;

        if let Some(errors) = response_body.errors {
            return Err(Error::GraphQL(errors));
        }

        let data = response_body.data.ok_or(Error::GraphQL(vec![]))?;

        Ok(data.ingest_vulnerability)
    }

    pub async fn vulnerabilities(&self, vuln: &VulnerabilitySpec) -> Result<Vec<Vulnerability>, Error> {
        use self::query::query_vulnerability;
        let variables = query_vulnerability::Variables { vuln: vuln.into() };
        let response_body = post_graphql::<QueryVulnerability, _>(self.client(), self.url(), variables).await?;

        if let Some(errors) = response_body.errors {
            return Err(Error::GraphQL(errors));
        }

        let data = response_body.data.ok_or(Error::GraphQL(vec![]))?;

        Ok(data.vulnerabilities.iter().map(|e| e.into()).collect())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Vulnerability {
    pub id: Id,
    pub r#type: String,
    pub vulnerability_ids: Vec<VulnerabilityId>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct VulnerabilityId {
    pub id: Id,
    pub vulnerability_id: String,
}

#[derive(Default, Clone, Debug)]
pub struct VulnerabilitySpec {
    pub id: Option<String>,
    pub r#type: Option<String>,
    pub vulnerability_id: Option<String>,
    pub no_vuln: Option<bool>,
}

impl VulnerabilitySpec {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_id(mut self, id: String) -> Self {
        self.id.replace(id);
        self
    }

    pub fn with_type(mut self, r#type: String) -> Self {
        self.r#type.replace(r#type);
        self
    }

    pub fn with_vulnerability_id(mut self, vulnerability_id: String) -> Self {
        self.vulnerability_id.replace(vulnerability_id);
        self
    }

    pub fn with_no_vuln(mut self, no_vuln: bool) -> Self {
        self.no_vuln.replace(no_vuln);
        self
    }
}

#[derive(Clone, Debug)]
pub struct VulnerabilityInputSpec {
    pub r#type: String,
    pub vulnerability_id: String,
}

impl VulnerabilityInputSpec {
    pub fn new(r#type: String, vulnerability_id: String) -> Self {
        Self {
            r#type,
            vulnerability_id,
        }
    }
}

impl From<&VulnerabilityInputSpec> for VulnerabilitySpec {
    fn from(value: &VulnerabilityInputSpec) -> Self {
        Self {
            id: None,
            r#type: Some(value.r#type.clone()),
            vulnerability_id: Some(value.vulnerability_id.clone()),
            no_vuln: None,
        }
    }
}
